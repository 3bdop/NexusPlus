import {
  Bounds,
  ContactShadows,
  Environment,
  MeshReflectorMaterial,
  PresentationControls,
  useBounds
} from "./chunk-C53SCQZE.js";
import "./chunk-YVTS555F.js";
import "./chunk-SHHD4MRE.js";
import "./chunk-ZED7HP2Z.js";
import "./chunk-XMQ3HDVI.js";
import {
  BlendFunction,
  Bloom,
  EffectComposer,
  SSAO,
  Vignette
} from "./chunk-I3UMPYGZ.js";
import {
  DRACOLoader,
  FBXLoader,
  GLTFLoader,
  OrbitControls
} from "./chunk-WH3IDLMT.js";
import {
  Canvas,
  suspend,
  useFrame,
  useGraph,
  useLoader,
  useThree
} from "./chunk-MRZWHJNP.js";
import {
  ACESFilmicToneMapping,
  AnimationMixer,
  Euler,
  LinearFilter,
  LoopRepeat,
  Object3D,
  TextureLoader,
  Vector2,
  Vector3
} from "./chunk-AZR45HN7.js";
import "./chunk-7IRX5BPU.js";
import {
  require_react
} from "./chunk-YI3AYBEL.js";
import {
  __toESM
} from "./chunk-USJHI7ER.js";

// node_modules/@readyplayerme/visage/dist/index.esm.js
var import_react = __toESM(require_react());
var environmentPresets = {
  hub: "hub",
  sunset: "sunset",
  dawn: "dawn",
  night: "night",
  warehouse: "warehouse",
  forest: "forest",
  apartment: "apartment",
  studio: "studio",
  city: "city",
  park: "park",
  lobby: "lobby",
  soft: "soft"
};
var getPresetEnvironmentMap = (preset) => `https://readyplayerme-assets.s3.amazonaws.com/environment/${preset}.hdr`;
var environmentModels = {
  spaceStation: "https://readyplayerme-assets.s3.amazonaws.com/props/environment-space-station.glb",
  platformDark: "https://readyplayerme-assets.s3.amazonaws.com/props/simple-platform-dark.glb",
  platformGreen: "https://readyplayerme-assets.s3.amazonaws.com/props/simple-platform-green.glb",
  platformBlue: "https://readyplayerme-assets.s3.amazonaws.com/props/simple-platform-blue.glb"
};
var Environment2 = ({ environment }) => {
  const config = (0, import_react.useMemo)(() => {
    const isStaticPreset = environment in environmentPresets;
    const files = isStaticPreset ? getPresetEnvironmentMap(environment) : environment;
    return {
      files
    };
  }, [environment]);
  return import_react.default.createElement(Environment, { files: config.files });
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var validateSource = (source) => {
  if (Array.isArray(source)) {
    return source.length > 0 && source.every(validateSource);
  }
  if (typeof source === "string") {
    const fileEndExpression = new RegExp(/(.glb|.fbx|.fbx[?].*|.glb[?].*)$/g);
    const uploadFileExpression = new RegExp(/^data:application\/octet-stream;base64,/g);
    const gltfModelExpression = new RegExp(/^data:model\/gltf-binary;base64,/g);
    return fileEndExpression.test(source) || uploadFileExpression.test(source) || gltfModelExpression.test(source);
  }
  if (source instanceof Blob) {
    return source.type === "model/gltf-binary";
  }
  return false;
};
var isValidFormat = (source) => {
  const isValid = validateSource(source);
  if (source && !isValid) {
    console.warn("Provided GLB/FBX is invalid. Check docs for supported formats: https://github.com/readyplayerme/visage");
  }
  return isValid;
};
var clamp = (value, max, min) => Math.min(Math.max(min, value), max);
var lerp = (start, end, time = 0.05) => start * (1 - time) + end * time;
var normaliseMaterialsConfig = (materials, bloomConfig) => {
  Object.values(materials).forEach((material) => {
    const mat = material;
    if (mat.map) {
      mat.map.minFilter = LinearFilter;
      mat.depthWrite = true;
    }
    if (mat.name.toLowerCase().includes("hair")) {
      mat.roughness = 0.9;
    }
    if (mat.emissiveMap) {
      mat.emissiveIntensity = (bloomConfig === null || bloomConfig === void 0 ? void 0 : bloomConfig.materialIntensity) || 3.3;
      mat.toneMapped = false;
    }
  });
};
var useHeadMovement = ({ nodes, isHalfBody = false, distance = 2, activeRotation = 0.2, rotationMargin = new Vector2(5, 10), enabled = false }) => {
  const rad = Math.PI / 180;
  const currentPos = new Vector2(0, 0);
  const targetPos = new Vector2(0, 0);
  const activeDistance = distance - (isHalfBody ? 1 : 0);
  const eyeRotationOffsetX = isHalfBody ? 90 * rad : 0;
  const neckBoneRotationOffsetX = (isHalfBody ? -5 : 10) * rad;
  const mapRange = (value, inMin, inMax, outMin, outMax) => (clamp(value, inMax, inMin) - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
  useFrame((state) => {
    if (!enabled || !nodes.Neck || !nodes.Head || !nodes.RightEye || !nodes.LeftEye) {
      return;
    }
    const cameraToHeadDistance = state.camera.position.distanceTo(nodes.Head.position);
    const cameraRotation = Math.abs(state.camera.rotation.z);
    if (cameraToHeadDistance < activeDistance && cameraRotation < activeRotation) {
      targetPos.x = mapRange(state.mouse.y, -0.5, 1, rotationMargin.x * rad, -rotationMargin.x * rad);
      targetPos.y = mapRange(state.mouse.x, -0.5, 0.5, -rotationMargin.y * rad, rotationMargin.y * rad);
    } else {
      targetPos.set(0, 0);
    }
    currentPos.x = lerp(currentPos.x, targetPos.x);
    currentPos.y = lerp(currentPos.y, targetPos.y);
    nodes.Neck.rotation.x = currentPos.x + neckBoneRotationOffsetX;
    nodes.Neck.rotation.y = currentPos.y;
    nodes.Head.rotation.x = currentPos.x;
    nodes.Head.rotation.y = currentPos.y;
    nodes.RightEye.rotation.x = currentPos.x - eyeRotationOffsetX;
    nodes.LeftEye.rotation.x = currentPos.x - eyeRotationOffsetX;
    if (isHalfBody) {
      nodes.RightEye.rotation.z = currentPos.y * 2 + Math.PI;
      nodes.LeftEye.rotation.z = currentPos.y * 2 + Math.PI;
    } else {
      nodes.RightEye.rotation.y = currentPos.y * 2;
      nodes.LeftEye.rotation.y = currentPos.y * 2;
    }
  });
};
var mutatePose = (targetNodes, sourceNodes) => {
  if (targetNodes && sourceNodes) {
    Object.keys(targetNodes).forEach((key) => {
      if (targetNodes[key].type === "Bone" && sourceNodes[key]) {
        const pos = sourceNodes[key].position;
        targetNodes[key].position.set(pos.x, pos.y, pos.z);
        const rot = sourceNodes[key].rotation;
        targetNodes[key].rotation.set(rot.x, rot.y, rot.z);
      }
    });
  }
};
var useEmotion = (nodes, emotion) => {
  const meshes = Object.values(nodes).filter((item) => item === null || item === void 0 ? void 0 : item.morphTargetInfluences);
  const resetEmotions = (resetMeshes) => {
    resetMeshes.forEach((mesh) => {
      var _a;
      (_a = mesh === null || mesh === void 0 ? void 0 : mesh.morphTargetInfluences) === null || _a === void 0 ? void 0 : _a.forEach((_, index) => {
        mesh.morphTargetInfluences[index] = 0;
      });
    });
  };
  useFrame(() => {
    if (emotion) {
      resetEmotions(meshes);
      meshes.forEach((mesh) => {
        Object.entries(emotion).forEach(([shape, value]) => {
          var _a;
          const shapeId = (_a = mesh === null || mesh === void 0 ? void 0 : mesh.morphTargetDictionary) === null || _a === void 0 ? void 0 : _a[shape];
          if (shapeId) {
            mesh.morphTargetInfluences[shapeId] = value;
          }
        });
      });
    } else {
      resetEmotions(meshes);
    }
  });
};
var loader = new GLTFLoader();
var dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.5/");
loader.setDRACOLoader(dracoLoader);
var useGltfLoader = (source) => suspend(() => __awaiter(void 0, void 0, void 0, function* () {
  if (source instanceof Blob) {
    const buffer = yield source.arrayBuffer();
    return yield loader.parseAsync(buffer, "");
  }
  return loader.loadAsync(source);
}), [source], { lifespan: 100 });
function usePersistantRotation(scene) {
  const refToPreviousScene = (0, import_react.useRef)(scene);
  (0, import_react.useEffect)(() => {
    if (refToPreviousScene.current !== scene) {
      scene.rotation.y = refToPreviousScene.current.rotation.y;
      refToPreviousScene.current = scene;
    }
  }, [scene]);
}
var Transform = class {
  constructor() {
    this.scale = new Vector3(1, 1, 1);
    this.rotation = new Euler(0, 0, 0);
    this.position = new Vector3(0, 0, 0);
  }
};
function buildFallback(nodes, transform = new Transform()) {
  return import_react.default.createElement("group", null, Object.keys(nodes).map((key) => {
    const node = nodes[key];
    if (node.type === "SkinnedMesh") {
      return import_react.default.createElement("skinnedMesh", { castShadow: true, receiveShadow: true, key: node.name, scale: transform.scale, position: transform.position, rotation: transform.rotation, geometry: node.geometry, material: node.material, skeleton: node.skeleton, morphTargetInfluences: node.morphTargetInfluences || [] });
    }
    if (node.type === "Mesh") {
      return import_react.default.createElement("mesh", { castShadow: true, receiveShadow: true, key: node.name, scale: transform.scale, position: transform.position, rotation: transform.rotation, geometry: node.geometry, material: node.material, morphTargetInfluences: node.morphTargetInfluences || [] });
    }
    return null;
  }));
}
var useFallback = (nodes, setter) => (0, import_react.useEffect)(() => {
  if (typeof setter === "function") {
    setter(buildFallback(nodes));
  }
}, [setter, nodes]);
var triggerCallback = (callback) => {
  if (typeof callback === "function") {
    callback();
  }
};
var expressions = {
  blink: [
    {
      morphTarget: "eyesClosed",
      morphTargetIndex: -1,
      offset: 0,
      duration: 0.2
    },
    {
      morphTarget: "eyeSquintLeft",
      morphTargetIndex: -1,
      offset: 0,
      duration: 0.2
    },
    {
      morphTarget: "eyeSquintRight",
      morphTargetIndex: -1,
      offset: 0,
      duration: 0.2
    }
  ]
};
var useIdleExpression = (expression, nodes) => {
  const headMesh = nodes.Wolf3D_Head || nodes.Wolf3D_Avatar;
  const selectedExpression = expression in expressions ? expressions[expression] : void 0;
  const timeout = (0, import_react.useRef)();
  const duration = (0, import_react.useRef)(Number.POSITIVE_INFINITY);
  (0, import_react.useEffect)(() => {
    if ((headMesh === null || headMesh === void 0 ? void 0 : headMesh.morphTargetDictionary) && selectedExpression) {
      for (let i = 0; i < selectedExpression.length; i++) {
        selectedExpression[i].morphTargetIndex = headMesh.morphTargetDictionary[selectedExpression[i].morphTarget];
      }
    }
  }, [selectedExpression === null || selectedExpression === void 0 ? void 0 : selectedExpression.length]);
  const animateExpression = (0, import_react.useCallback)((delta) => {
    if ((headMesh === null || headMesh === void 0 ? void 0 : headMesh.morphTargetInfluences) && selectedExpression) {
      duration.current += delta;
      for (let i = 0; i < selectedExpression.length; i++) {
        const section = selectedExpression[i];
        if (duration.current < section.duration + section.offset) {
          if (duration.current > section.offset) {
            const pivot = (duration.current - section.offset) / section.duration * Math.PI;
            const morphInfluence = Math.sin(pivot);
            headMesh.morphTargetInfluences[section.morphTargetIndex] = morphInfluence;
          }
        } else {
          headMesh.morphTargetInfluences[section.morphTargetIndex] = 0;
        }
      }
    }
  }, [headMesh === null || headMesh === void 0 ? void 0 : headMesh.morphTargetInfluences, selectedExpression, duration.current, timeout.current]);
  const setNextInterval = () => {
    duration.current = 0;
    const delay = Math.random() * 3e3 + 3e3;
    clearTimeout(timeout.current);
    timeout.current = setTimeout(setNextInterval, delay);
  };
  (0, import_react.useEffect)(() => {
    if (selectedExpression) {
      timeout.current = setTimeout(setNextInterval, 3e3);
    }
    return () => {
      clearTimeout(timeout.current);
    };
  }, [selectedExpression]);
  useFrame((_, delta) => {
    if (headMesh && selectedExpression) {
      animateExpression(delta);
    }
  });
};
var hasWindow = typeof window !== "undefined";
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = (get) => get(config);
    config.write = (get, set, arg) => set(
      config,
      typeof arg === "function" ? arg(get(config)) : arg
    );
  }
  if (write) {
    config.write = write;
  }
  return config;
}
var hasInitialValue = (atom2) => "init" in atom2;
var isActuallyWritableAtom = (atom2) => !!atom2.write;
var cancelPromiseMap = /* @__PURE__ */ new WeakMap();
var registerCancelPromise = (promise, cancel) => {
  cancelPromiseMap.set(promise, cancel);
  promise.catch(() => {
  }).finally(() => cancelPromiseMap.delete(promise));
};
var cancelPromise = (promise, next) => {
  const cancel = cancelPromiseMap.get(promise);
  if (cancel) {
    cancelPromiseMap.delete(promise);
    cancel(next);
  }
};
var resolvePromise = (promise, value) => {
  promise.status = "fulfilled";
  promise.value = value;
};
var rejectPromise = (promise, e) => {
  promise.status = "rejected";
  promise.reason = e;
};
var isPromiseLike$1 = (x) => typeof (x == null ? void 0 : x.then) === "function";
var isEqualAtomValue = (a, b) => "v" in a && "v" in b && Object.is(a.v, b.v);
var isEqualAtomError = (a, b) => "e" in a && "e" in b && Object.is(a.e, b.e);
var hasPromiseAtomValue = (a) => "v" in a && a.v instanceof Promise;
var isEqualPromiseAtomValue = (a, b) => "v" in a && "v" in b && a.v.orig && a.v.orig === b.v.orig;
var returnAtomValue = (atomState) => {
  if ("e" in atomState) {
    throw atomState.e;
  }
  return atomState.v;
};
var createStore = () => {
  const atomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let storeListenersRev1;
  let storeListenersRev2;
  let mountedAtoms;
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    storeListenersRev1 = /* @__PURE__ */ new Set();
    storeListenersRev2 = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  const getAtomState = (atom2) => atomStateMap.get(atom2);
  const setAtomState = (atom2, atomState) => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      Object.freeze(atomState);
    }
    const prevAtomState = atomStateMap.get(atom2);
    atomStateMap.set(atom2, atomState);
    if (!pendingMap.has(atom2)) {
      pendingMap.set(atom2, prevAtomState);
    }
    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {
      const next = "v" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);
      cancelPromise(prevAtomState.v, next);
    }
  };
  const updateDependencies = (atom2, nextAtomState, nextDependencies) => {
    const dependencies = /* @__PURE__ */ new Map();
    let changed = false;
    nextDependencies.forEach((aState, a) => {
      if (!aState && a === atom2) {
        aState = nextAtomState;
      }
      if (aState) {
        dependencies.set(a, aState);
        if (nextAtomState.d.get(a) !== aState) {
          changed = true;
        }
      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
        console.warn("[Bug] atom state not found");
      }
    });
    if (changed || nextAtomState.d.size !== dependencies.size) {
      nextAtomState.d = dependencies;
    }
  };
  const setAtomValue = (atom2, value, nextDependencies) => {
    const prevAtomState = getAtomState(atom2);
    const nextAtomState = {
      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
      v: value
    };
    if (nextDependencies) {
      updateDependencies(atom2, nextAtomState, nextDependencies);
    }
    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
      return prevAtomState;
    }
    if (prevAtomState && hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {
      if (prevAtomState.d === nextAtomState.d) {
        return prevAtomState;
      } else {
        nextAtomState.v = prevAtomState.v;
      }
    }
    setAtomState(atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomValueOrPromise = (atom2, valueOrPromise, nextDependencies, abortPromise) => {
    if (isPromiseLike$1(valueOrPromise)) {
      let continuePromise;
      const promise = new Promise((resolve, reject) => {
        let settled = false;
        valueOrPromise.then(
          (v) => {
            if (!settled) {
              settled = true;
              const prevAtomState = getAtomState(atom2);
              const nextAtomState = setAtomValue(
                atom2,
                promise,
                nextDependencies
              );
              resolvePromise(promise, v);
              resolve(v);
              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {
                mountDependencies(atom2, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);
              }
            }
          },
          (e) => {
            if (!settled) {
              settled = true;
              const prevAtomState = getAtomState(atom2);
              const nextAtomState = setAtomValue(
                atom2,
                promise,
                nextDependencies
              );
              rejectPromise(promise, e);
              reject(e);
              if ((prevAtomState == null ? void 0 : prevAtomState.d) !== nextAtomState.d) {
                mountDependencies(atom2, nextAtomState, prevAtomState == null ? void 0 : prevAtomState.d);
              }
            }
          }
        );
        continuePromise = (next) => {
          if (!settled) {
            settled = true;
            next.then(
              (v) => resolvePromise(promise, v),
              (e) => rejectPromise(promise, e)
            );
            resolve(next);
          }
        };
      });
      promise.orig = valueOrPromise;
      promise.status = "pending";
      registerCancelPromise(promise, (next) => {
        if (next) {
          continuePromise(next);
        }
        abortPromise == null ? void 0 : abortPromise();
      });
      return setAtomValue(atom2, promise, nextDependencies);
    }
    return setAtomValue(atom2, valueOrPromise, nextDependencies);
  };
  const setAtomError = (atom2, error, nextDependencies) => {
    const prevAtomState = getAtomState(atom2);
    const nextAtomState = {
      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
      e: error
    };
    if (nextDependencies) {
      updateDependencies(atom2, nextAtomState, nextDependencies);
    }
    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
      return prevAtomState;
    }
    setAtomState(atom2, nextAtomState);
    return nextAtomState;
  };
  const readAtomState = (atom2) => {
    const atomState = getAtomState(atom2);
    if (atomState) {
      atomState.d.forEach((_, a) => {
        if (a !== atom2 && !mountedMap.has(a)) {
          readAtomState(a);
        }
      });
      if (Array.from(atomState.d).every(([a, s]) => {
        const aState = getAtomState(a);
        return a === atom2 || aState === s || // TODO This is a hack, we should find a better solution.
        aState && !hasPromiseAtomValue(aState) && isEqualAtomValue(aState, s);
      })) {
        return atomState;
      }
    }
    const nextDependencies = /* @__PURE__ */ new Map();
    let isSync = true;
    const getter = (a) => {
      if (a === atom2) {
        const aState2 = getAtomState(a);
        if (aState2) {
          nextDependencies.set(a, aState2);
          return returnAtomValue(aState2);
        }
        if (hasInitialValue(a)) {
          nextDependencies.set(a, void 0);
          return a.init;
        }
        throw new Error("no atom init");
      }
      const aState = readAtomState(a);
      nextDependencies.set(a, aState);
      return returnAtomValue(aState);
    };
    let controller;
    let setSelf;
    const options = {
      get signal() {
        if (!controller) {
          controller = new AbortController();
        }
        return controller.signal;
      },
      get setSelf() {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
          console.warn("setSelf function cannot be used with read-only atom");
        }
        if (!setSelf && isActuallyWritableAtom(atom2)) {
          setSelf = (...args) => {
            if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && isSync) {
              console.warn("setSelf function cannot be called in sync");
            }
            if (!isSync) {
              return writeAtom(atom2, ...args);
            }
          };
        }
        return setSelf;
      }
    };
    try {
      const valueOrPromise = atom2.read(getter, options);
      return setAtomValueOrPromise(
        atom2,
        valueOrPromise,
        nextDependencies,
        () => controller == null ? void 0 : controller.abort()
      );
    } catch (error) {
      return setAtomError(atom2, error, nextDependencies);
    } finally {
      isSync = false;
    }
  };
  const readAtom = (atom2) => returnAtomValue(readAtomState(atom2));
  const addAtom = (atom2) => {
    let mounted = mountedMap.get(atom2);
    if (!mounted) {
      mounted = mountAtom(atom2);
    }
    return mounted;
  };
  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));
  const delAtom = (atom2) => {
    const mounted = mountedMap.get(atom2);
    if (mounted && canUnmountAtom(atom2, mounted)) {
      unmountAtom(atom2);
    }
  };
  const recomputeDependents = (atom2) => {
    const dependencyMap = /* @__PURE__ */ new Map();
    const dirtyMap = /* @__PURE__ */ new WeakMap();
    const loop1 = (a) => {
      const mounted = mountedMap.get(a);
      mounted == null ? void 0 : mounted.t.forEach((dependent) => {
        if (dependent !== a) {
          dependencyMap.set(
            dependent,
            (dependencyMap.get(dependent) || /* @__PURE__ */ new Set()).add(a)
          );
          dirtyMap.set(dependent, (dirtyMap.get(dependent) || 0) + 1);
          loop1(dependent);
        }
      });
    };
    loop1(atom2);
    const loop2 = (a) => {
      const mounted = mountedMap.get(a);
      mounted == null ? void 0 : mounted.t.forEach((dependent) => {
        var _a;
        if (dependent !== a) {
          let dirtyCount = dirtyMap.get(dependent);
          if (dirtyCount) {
            dirtyMap.set(dependent, --dirtyCount);
          }
          if (!dirtyCount) {
            let isChanged = !!((_a = dependencyMap.get(dependent)) == null ? void 0 : _a.size);
            if (isChanged) {
              const prevAtomState = getAtomState(dependent);
              const nextAtomState = readAtomState(dependent);
              isChanged = !prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState);
            }
            if (!isChanged) {
              dependencyMap.forEach((s) => s.delete(dependent));
            }
          }
          loop2(dependent);
        }
      });
    };
    loop2(atom2);
  };
  const writeAtomState = (atom2, ...args) => {
    let isSync = true;
    const getter = (a) => returnAtomValue(readAtomState(a));
    const setter = (a, ...args2) => {
      let r;
      if (a === atom2) {
        if (!hasInitialValue(a)) {
          throw new Error("atom not writable");
        }
        const prevAtomState = getAtomState(a);
        const nextAtomState = setAtomValueOrPromise(a, args2[0]);
        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {
          recomputeDependents(a);
        }
      } else {
        r = writeAtomState(a, ...args2);
      }
      if (!isSync) {
        const flushed = flushPending();
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          storeListenersRev2.forEach(
            (l) => l({ type: "async-write", flushed })
          );
        }
      }
      return r;
    };
    const result = atom2.write(getter, setter, ...args);
    isSync = false;
    return result;
  };
  const writeAtom = (atom2, ...args) => {
    const result = writeAtomState(atom2, ...args);
    const flushed = flushPending();
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      storeListenersRev2.forEach(
        (l) => l({ type: "write", flushed })
      );
    }
    return result;
  };
  const mountAtom = (atom2, initialDependent) => {
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom2, mounted);
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      mountedAtoms.add(atom2);
    }
    readAtomState(atom2).d.forEach((_, a) => {
      const aMounted = mountedMap.get(a);
      if (aMounted) {
        aMounted.t.add(atom2);
      } else {
        if (a !== atom2) {
          mountAtom(a, atom2);
        }
      }
    });
    readAtomState(atom2);
    if (isActuallyWritableAtom(atom2) && atom2.onMount) {
      const onUnmount = atom2.onMount((...args) => writeAtom(atom2, ...args));
      if (onUnmount) {
        mounted.u = onUnmount;
      }
    }
    return mounted;
  };
  const unmountAtom = (atom2) => {
    var _a;
    const onUnmount = (_a = mountedMap.get(atom2)) == null ? void 0 : _a.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom2);
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      mountedAtoms.delete(atom2);
    }
    const atomState = getAtomState(atom2);
    if (atomState) {
      if (hasPromiseAtomValue(atomState)) {
        cancelPromise(atomState.v);
      }
      atomState.d.forEach((_, a) => {
        if (a !== atom2) {
          const mounted = mountedMap.get(a);
          if (mounted) {
            mounted.t.delete(atom2);
            if (canUnmountAtom(a, mounted)) {
              unmountAtom(a);
            }
          }
        }
      });
    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom2);
    }
  };
  const mountDependencies = (atom2, atomState, prevDependencies) => {
    const depSet = new Set(atomState.d.keys());
    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {
      if (depSet.has(a)) {
        depSet.delete(a);
        return;
      }
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.delete(atom2);
        if (canUnmountAtom(a, mounted)) {
          unmountAtom(a);
        }
      }
    });
    depSet.forEach((a) => {
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.add(atom2);
      } else if (mountedMap.has(atom2)) {
        mountAtom(a, atom2);
      }
    });
  };
  const flushPending = () => {
    let flushed;
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      flushed = /* @__PURE__ */ new Set();
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom2, prevAtomState]) => {
        const atomState = getAtomState(atom2);
        if (atomState) {
          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
            mountDependencies(atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
          }
          const mounted = mountedMap.get(atom2);
          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.
          // Maybe we could `mountDependencies` in `setAtomState`?
          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {
            mounted.l.forEach((listener) => listener());
            if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
              flushed.add(atom2);
            }
          }
        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          console.warn("[Bug] no atom state to flush");
        }
      });
    }
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      storeListenersRev1.forEach((l) => l("state"));
      return flushed;
    }
  };
  const subscribeAtom = (atom2, listener) => {
    const mounted = addAtom(atom2);
    const flushed = flushPending();
    const listeners = mounted.l;
    listeners.add(listener);
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      storeListenersRev1.forEach((l) => l("sub"));
      storeListenersRev2.forEach(
        (l) => l({ type: "sub", flushed })
      );
    }
    return () => {
      listeners.delete(listener);
      delAtom(atom2);
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
        storeListenersRev1.forEach((l) => l("unsub"));
        storeListenersRev2.forEach((l) => l({ type: "unsub" }));
      }
    };
  };
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    return {
      get: readAtom,
      set: writeAtom,
      sub: subscribeAtom,
      // store dev methods (these are tentative and subject to change without notice)
      dev_subscribe_store: (l, rev) => {
        if (rev !== 2) {
          console.warn(
            "The current StoreListener revision is 2. The older ones are deprecated."
          );
          storeListenersRev1.add(l);
          return () => {
            storeListenersRev1.delete(l);
          };
        }
        storeListenersRev2.add(l);
        return () => {
          storeListenersRev2.delete(l);
        };
      },
      dev_get_mounted_atoms: () => mountedAtoms.values(),
      dev_get_atom_state: (a) => atomStateMap.get(a),
      dev_get_mounted: (a) => mountedMap.get(a),
      dev_restore_atoms: (values) => {
        for (const [atom2, valueOrPromise] of values) {
          if (hasInitialValue(atom2)) {
            setAtomValueOrPromise(atom2, valueOrPromise);
            recomputeDependents(atom2);
          }
        }
        const flushed = flushPending();
        storeListenersRev2.forEach(
          (l) => l({ type: "restore", flushed })
        );
      }
    };
  }
  return {
    get: readAtom,
    set: writeAtom,
    sub: subscribeAtom
  };
};
var defaultStore;
var getDefaultStore = () => {
  if (!defaultStore) {
    defaultStore = createStore();
  }
  return defaultStore;
};
if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
  if (globalThis.__JOTAI_PACKAGE_IS_LOADED__) {
    console.warn(
      "Detected multiple Jotai instances. It may cause unexpected behavior. https://github.com/pmndrs/jotai/discussions/2044"
    );
  } else {
    globalThis.__JOTAI_PACKAGE_IS_LOADED__ = true;
  }
}
var StoreContext = (0, import_react.createContext)(void 0);
var useStore = (options) => {
  const store = (0, import_react.useContext)(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
};
var Provider = ({
  children,
  store
}) => {
  const storeRef = (0, import_react.useRef)();
  if (!store && !storeRef.current) {
    storeRef.current = createStore();
  }
  return (0, import_react.createElement)(
    StoreContext.Provider,
    {
      value: store || storeRef.current
    },
    children
  );
};
var isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === "function";
var use = import_react.default.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
    throw promise;
  }
});
function useAtomValue(atom2, options) {
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  const delay = options == null ? void 0 : options.delay;
  (0, import_react.useEffect)(() => {
    const unsub = store.sub(atom2, () => {
      if (typeof delay === "number") {
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay]);
  (0, import_react.useDebugValue)(value);
  return isPromiseLike(value) ? use(value) : value;
}
function useSetAtom(atom2, options) {
  const store = useStore(options);
  const setAtom = (0, import_react.useCallback)(
    (...args) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}
var MIXAMO_PREFIX = "mixamorig";
var POSITION_SUFFIX = ".position";
var MIXAMO_SCALE = 0.01;
var fbxLoader = new FBXLoader();
var gltfLoader = new GLTFLoader();
function normaliseFbxAnimation(fbx, index = 0) {
  const { tracks } = fbx.animations[index];
  for (let i = 0; i < tracks.length; i += 1) {
    const hasMixamoPrefix = tracks[i].name.includes(MIXAMO_PREFIX);
    if (hasMixamoPrefix) {
      tracks[i].name = tracks[i].name.replace(MIXAMO_PREFIX, "");
    }
    if (tracks[i].name.includes(POSITION_SUFFIX)) {
      for (let j = 0; j < tracks[i].values.length; j += 1) {
        tracks[i].values[j] = tracks[i].values[j] * MIXAMO_SCALE;
      }
    }
  }
  return fbx.animations[index];
}
var loadBlobFile = (blob) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const buffer = yield blob.arrayBuffer();
    return {
      group: yield gltfLoader.parseAsync(buffer, ""),
      isFbx: false
    };
  } catch (e) {
    return {
      group: yield fbxLoader.loadAsync(URL.createObjectURL(blob)),
      isFbx: true
    };
  }
});
var loadPathFile = (source) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    return {
      group: yield gltfLoader.loadAsync(source),
      isFbx: false
    };
  } catch (e) {
    return {
      group: yield fbxLoader.loadAsync(source),
      isFbx: true
    };
  }
});
var loadAnimationClip = (source) => __awaiter(void 0, void 0, void 0, function* () {
  const animation = source instanceof Blob ? yield loadBlobFile(source) : yield loadPathFile(source);
  return animation.isFbx ? normaliseFbxAnimation(animation.group) : animation.group.animations[0];
});
var SpawnEffect = ({ onLoadedEffect, onLoadedEffectFinish }) => {
  const ref = (0, import_react.useRef)(null);
  const [effectRunning, setEffectRunning] = import_react.default.useState(true);
  const { scene: mountEffectScene } = useGltfLoader(onLoadedEffect.src);
  const { nodes: mountEffectNode } = useGraph(mountEffectScene);
  (0, import_react.useEffect)(() => {
    if (!effectRunning) {
      triggerCallback(onLoadedEffectFinish);
    }
  }, [onLoadedEffectFinish, effectRunning]);
  const animationLoadedEffect = (0, import_react.useMemo)(() => __awaiter(void 0, void 0, void 0, function* () {
    return loadAnimationClip((onLoadedEffect === null || onLoadedEffect === void 0 ? void 0 : onLoadedEffect.animationSrc) || onLoadedEffect.src);
  }), [onLoadedEffect === null || onLoadedEffect === void 0 ? void 0 : onLoadedEffect.animationSrc, onLoadedEffect.src]);
  const spawnEffectMixer = (0, import_react.useMemo)(() => __awaiter(void 0, void 0, void 0, function* () {
    const mixer = new AnimationMixer(mountEffectNode.Scene);
    const loadedEffect = yield animationLoadedEffect;
    if (!loadedEffect) {
      setEffectRunning(false);
      return mixer;
    }
    const animation = mixer.clipAction(loadedEffect);
    animation.setLoop(LoopRepeat, (onLoadedEffect === null || onLoadedEffect === void 0 ? void 0 : onLoadedEffect.loop) || 1);
    animation.clampWhenFinished = true;
    animation.play();
    mixer.addEventListener("finished", () => {
      animation.fadeOut(0.5);
      setEffectRunning(false);
    });
    return mixer;
  }), [mountEffectNode.Scene, animationLoadedEffect, onLoadedEffect === null || onLoadedEffect === void 0 ? void 0 : onLoadedEffect.loop]);
  useFrame((state, delta) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    (_a = yield spawnEffectMixer) === null || _a === void 0 ? void 0 : _a.update(delta);
  }));
  return import_react.default.createElement(import_react.default.Fragment, null, effectRunning && import_react.default.createElement("primitive", { modelRef: ref, object: mountEffectScene }));
};
var SpawnAnimation = ({ avatar, onLoadedAnimationFinish, onLoadedAnimation }) => {
  const [animationRunning, setAnimationRunning] = import_react.default.useState(true);
  (0, import_react.useEffect)(() => {
    if (!animationRunning) {
      triggerCallback(onLoadedAnimationFinish);
    }
  }, [onLoadedAnimationFinish, animationRunning]);
  const { nodes: avatarNode } = useGraph(avatar);
  const animationClip = (0, import_react.useMemo)(() => __awaiter(void 0, void 0, void 0, function* () {
    return loadAnimationClip((onLoadedAnimation === null || onLoadedAnimation === void 0 ? void 0 : onLoadedAnimation.src) || "");
  }), [onLoadedAnimation === null || onLoadedAnimation === void 0 ? void 0 : onLoadedAnimation.src]);
  const animationMixerAvatar = (0, import_react.useMemo)(() => __awaiter(void 0, void 0, void 0, function* () {
    const mixer = new AnimationMixer(avatarNode.Armature);
    if (!avatarNode.Armature) {
      return mixer;
    }
    const animation = mixer.clipAction(yield animationClip);
    animation.setLoop(LoopRepeat, (onLoadedAnimation === null || onLoadedAnimation === void 0 ? void 0 : onLoadedAnimation.loop) || 1);
    animation.clampWhenFinished = true;
    animation.play();
    mixer.addEventListener("finished", () => {
      animation.fadeOut(0.5);
      setAnimationRunning(false);
    });
    return mixer;
  }), [avatarNode.Armature, onLoadedAnimation === null || onLoadedAnimation === void 0 ? void 0 : onLoadedAnimation.loop, animationClip]);
  useFrame((state, delta) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    (_a = yield animationMixerAvatar) === null || _a === void 0 ? void 0 : _a.update(delta);
  }));
  return import_react.default.createElement(import_react.default.Fragment, null);
};
var initialSpawnState = {
  onLoadedEffect: null,
  onLoadedAnimation: null
};
var spawnState = atom(initialSpawnState);
var Spawn = ({ avatar, onSpawnFinish }) => {
  var _a, _b;
  const animationProps = useAtomValue(spawnState);
  const usesMountEffect = isValidFormat((_a = animationProps === null || animationProps === void 0 ? void 0 : animationProps.onLoadedEffect) === null || _a === void 0 ? void 0 : _a.src);
  const usesMountAnimation = isValidFormat((_b = animationProps === null || animationProps === void 0 ? void 0 : animationProps.onLoadedAnimation) === null || _b === void 0 ? void 0 : _b.src);
  const [effectRunning, setEffectRunning] = import_react.default.useState(usesMountEffect);
  const [animationRunning, setAnimationRunning] = import_react.default.useState(usesMountAnimation);
  (0, import_react.useEffect)(() => {
    if (!animationRunning && !effectRunning) {
      triggerCallback(onSpawnFinish);
    }
  }, [onSpawnFinish, effectRunning, animationRunning]);
  const onLoadedAnimationFinish = () => {
    setAnimationRunning(false);
  };
  const onLoadedEffectFinish = () => {
    setEffectRunning(false);
  };
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    usesMountEffect && import_react.default.createElement(SpawnEffect, { onLoadedEffect: animationProps.onLoadedEffect, onLoadedEffectFinish }),
    usesMountAnimation && import_react.default.createElement(SpawnAnimation, { onLoadedAnimation: animationProps.onLoadedAnimation, avatar, onLoadedAnimationFinish })
  );
};
var ROTATION_STEP = 5e-3;
var Model = ({ scene, scale = 1, modelRef, onLoaded, onSpawnAnimationFinish, bloom }) => {
  const { materials } = useGraph(scene);
  const { gl } = useThree();
  const [isTouching, setIsTouching] = (0, import_react.useState)(false);
  const [touchEvent, setTouchEvent] = (0, import_react.useState)(null);
  const setTouchingOn = (e) => {
    if (hasWindow && window.TouchEvent && e instanceof TouchEvent) {
      setTouchEvent(e);
    }
    setIsTouching(true);
  };
  const setTouchingOff = (e) => {
    if (hasWindow && window.TouchEvent && e instanceof TouchEvent) {
      setTouchEvent(null);
    }
    setIsTouching(false);
  };
  usePersistantRotation(scene);
  const onTouchMove = (0, import_react.useCallback)((event) => {
    if (isTouching && event instanceof MouseEvent) {
      scene.rotation.y += event.movementX * ROTATION_STEP;
    }
    if (hasWindow && isTouching && window.TouchEvent && event instanceof TouchEvent) {
      const movementX = Math.round(event.touches[0].pageX - touchEvent.touches[0].pageX);
      scene.rotation.y += movementX * ROTATION_STEP;
      setTouchEvent(event);
    }
  }, [isTouching, touchEvent, scene]);
  normaliseMaterialsConfig(materials, bloom);
  scene.traverse((object) => {
    const node = object;
    if (node.isMesh) {
      node.castShadow = true;
    }
    if (node.type === "SkinnedMesh") {
      node.receiveShadow = true;
    }
  });
  (0, import_react.useEffect)(() => triggerCallback(onLoaded), [scene, materials, onLoaded]);
  (0, import_react.useEffect)(() => {
    gl.domElement.addEventListener("mousedown", setTouchingOn);
    gl.domElement.addEventListener("touchstart", setTouchingOn, { passive: true });
    window.addEventListener("mouseup", setTouchingOff);
    gl.domElement.addEventListener("touchend", setTouchingOff);
    gl.domElement.addEventListener("touchcancel", setTouchingOff);
    window.addEventListener("mousemove", onTouchMove);
    gl.domElement.addEventListener("touchmove", onTouchMove, { passive: true });
    return () => {
      gl.domElement.removeEventListener("mousedown", setTouchingOn);
      gl.domElement.removeEventListener("touchstart", setTouchingOn);
      window.removeEventListener("mouseup", setTouchingOff);
      gl.domElement.removeEventListener("touchend", setTouchingOff);
      gl.domElement.removeEventListener("touchcancel", setTouchingOff);
      window.removeEventListener("mousemove", onTouchMove);
      gl.domElement.removeEventListener("touchmove", onTouchMove);
    };
  });
  const spawnComponent = (0, import_react.useMemo)(() => import_react.default.createElement(Spawn, { avatar: scene, onSpawnFinish: onSpawnAnimationFinish }), [onSpawnAnimationFinish]);
  return import_react.default.createElement(
    "group",
    { ref: modelRef, dispose: null, rotation: [0, 0, 0] },
    import_react.default.createElement("primitive", { object: scene, scale }),
    spawnComponent
  );
};
var FloatingModel = ({ modelSrc, scale = 1, onLoaded, bloom }) => {
  const ref = (0, import_react.useRef)(null);
  const { scene } = useGltfLoader(modelSrc);
  useFrame((state) => {
    const t = state.clock.getElapsedTime();
    if (ref === null || ref === void 0 ? void 0 : ref.current) {
      ref.current.rotation.y = Math.sin(t / 2) / 8;
      ref.current.position.y = (1 + Math.sin(t / 1.5)) / -9;
    }
  });
  return import_react.default.createElement(Model, { modelRef: ref, scale, scene, onLoaded, bloom });
};
var FloatingModelContainer = (props) => {
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback },
    import_react.default.createElement(FloatingModel, Object.assign({}, props, { setModelFallback: setFallback }))
  );
};
var StaticModel = ({ modelSrc, modelRef, scale = 1, setModelFallback, onLoaded, emotion, bloom }) => {
  const { scene } = useGltfLoader(modelSrc);
  const { nodes } = useGraph(scene);
  useEmotion(nodes, emotion);
  useFallback(nodes, setModelFallback);
  return import_react.default.createElement(Model, { modelRef, scene, scale, onLoaded, bloom });
};
var StaticModelContainer = (props) => {
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback },
    import_react.default.createElement(StaticModel, Object.assign({ setModelFallback: setFallback }, props))
  );
};
var BoundsModelContainer = ({ modelSrc, children, fit, onLoaded }) => {
  const bounds = useBounds();
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  const onChildLoaded = (0, import_react.useCallback)(() => {
    if (fit) {
      bounds.refresh().clip().fit();
    }
    triggerCallback(onLoaded);
  }, [bounds, fit]);
  const childModel = (0, import_react.useMemo)(() => import_react.default.Children.map(children, (child) => (0, import_react.cloneElement)(child, { setModelFallback: setFallback, onLoaded: onChildLoaded })), [modelSrc, children, onChildLoaded]);
  (0, import_react.useEffect)(() => {
    if (fit) {
      bounds.refresh().clip().fit();
    }
  }, [modelSrc, fit, fallback]);
  return import_react.default.createElement(import_react.default.Fragment, null, childModel);
};
function styleInject(css, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = ".BaseCanvas-module_base-canvas__Xjohd {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}";
var styles$1 = { "base-canvas": "BaseCanvas-module_base-canvas__Xjohd" };
styleInject(css_248z$1);
var BASE_DPR = hasWindow ? window.devicePixelRatio : 1;
var BaseCanvas = ({ children = void 0, fov = 50, position = new Vector3(0, 0, 5), style, dpr = [BASE_DPR * 0.5, 2], className }) => import_react.default.createElement(Canvas, { key: fov, className: `${styles$1["base-canvas"]} ${className !== null && className !== void 0 ? className : ""}`, shadows: "soft", gl: { preserveDrawingBuffer: true, alpha: true, toneMappingExposure: 1.6, toneMapping: ACESFilmicToneMapping }, dpr, camera: { fov, position }, resize: { scroll: true, debounce: { scroll: 50, resize: 0 } }, style: Object.assign(Object.assign({}, style), { background: "transparent" }) }, children);
var Capture = ({ trigger, settings, callBack }) => {
  const gl = useThree((state) => state.gl);
  const type = (settings === null || settings === void 0 ? void 0 : settings.type) || "image/png";
  const quality = (settings === null || settings === void 0 ? void 0 : settings.quality) || 0.1;
  (0, import_react.useEffect)(() => {
    if (trigger) {
      const capture = gl.domElement.toDataURL(type, quality);
      callBack(capture);
    }
  }, [trigger]);
  return import_react.default.createElement(import_react.default.Fragment, null);
};
var BackgroundColor = ({ color }) => import_react.default.createElement("color", { attach: "background", args: [color] });
var Box = (_a) => {
  var { src = "" } = _a, baseProps = __rest(_a, ["src"]);
  const ref = (0, import_react.useRef)(null);
  const texture = useLoader(TextureLoader, src);
  return import_react.default.createElement(
    "mesh",
    Object.assign({ ref, castShadow: true, receiveShadow: true }, baseProps),
    import_react.default.createElement("boxBufferGeometry", null),
    import_react.default.createElement("meshPhysicalMaterial", { map: texture })
  );
};
var Exhibit = ({ modelSrc, scale = 1, environment = "city", position, style, className, shadows = false, float = false, fit = false, capture, snap = false, lockVertical = false, onLoaded, onLoading }) => {
  const model = (0, import_react.useMemo)(() => {
    if (!isValidFormat(modelSrc)) {
      return null;
    }
    if (!float) {
      return import_react.default.createElement(StaticModelContainer, { modelSrc, scale });
    }
    return import_react.default.createElement(FloatingModelContainer, { modelSrc, scale });
  }, [float, modelSrc, scale]);
  (0, import_react.useEffect)(() => triggerCallback(onLoading), [modelSrc, onLoading]);
  return import_react.default.createElement(
    BaseCanvas,
    { position, style, className },
    import_react.default.createElement(
      import_react.Suspense,
      { fallback: null },
      import_react.default.createElement("ambientLight", { intensity: 0.5 }),
      import_react.default.createElement("spotLight", { position: [10, 10, 10], angle: 0.15, penumbra: 1, "shadow-mapSize": [512, 512], castShadow: true }),
      import_react.default.createElement(PresentationControls, { global: true, config: { mass: 2, tension: 500 }, snap, rotation: [0, -0.3, 0], polar: lockVertical ? [0, 0] : [-Math.PI / 3, Math.PI / 3], azimuth: [-Infinity, Infinity] }, model && import_react.default.createElement(
        Bounds,
        { fit, clip: fit, observe: fit },
        import_react.default.createElement(BoundsModelContainer, { modelSrc, fit, onLoaded }, model)
      )),
      shadows && import_react.default.createElement(ContactShadows, { position: [0, -1, 0], opacity: 0.75, scale: 10, blur: 2.6, far: 2 }),
      import_react.default.createElement(Environment2, { environment })
    ),
    capture && import_react.default.createElement(Capture, Object.assign({}, capture)),
    (style === null || style === void 0 ? void 0 : style.background) && import_react.default.createElement(BackgroundColor, { color: style.background })
  );
};
var currentRotation$1 = 0;
var AnimationModel = ({ modelSrc, animationSrc, rotation = 20 * (Math.PI / 180), scale = 1, idleRotation = false, setModelFallback, onLoaded, headMovement = false, emotion, bloom }) => {
  const ref = (0, import_react.useRef)(null);
  const [animationRunning, setAnimationRunning] = (0, import_react.useState)(true);
  const onSpawnAnimationFinish = () => {
    setAnimationRunning(false);
  };
  const { scene } = useGltfLoader(modelSrc);
  const { nodes } = useGraph(scene);
  const animationClip = (0, import_react.useMemo)(() => __awaiter(void 0, void 0, void 0, function* () {
    return loadAnimationClip(animationSrc);
  }), [animationSrc]);
  const animationMixer = (0, import_react.useMemo)(() => __awaiter(void 0, void 0, void 0, function* () {
    const mixer = new AnimationMixer(nodes.Armature);
    if (animationRunning) {
      return mixer;
    }
    const animation = mixer.clipAction(yield animationClip);
    animation.fadeIn(0);
    animation.play();
    mixer.update(0);
    return mixer;
  }), [animationRunning, animationClip, nodes.Armature]);
  useFrame((state, delta) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    (_a = yield animationMixer) === null || _a === void 0 ? void 0 : _a.update(delta);
    if (!idleRotation) {
      return;
    }
    if (ref === null || ref === void 0 ? void 0 : ref.current) {
      currentRotation$1 += delta * 0.2;
      ref.current.rotation.y = rotation + Math.sin(currentRotation$1) / 3;
    }
  }));
  useHeadMovement({ nodes, enabled: headMovement });
  useEmotion(nodes, emotion);
  useIdleExpression("blink", nodes);
  useFallback(nodes, setModelFallback);
  return import_react.default.createElement(Model, { modelRef: ref, scene, scale, onLoaded, onSpawnAnimationFinish, bloom });
};
var AnimationModelContainer = (props) => {
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback },
    import_react.default.createElement(AnimationModel, Object.assign({ setModelFallback: setFallback }, props))
  );
};
var currentRotation = 0;
var HalfBodyModel = ({ modelSrc, scale = 1, rotation = 20 * (Math.PI / 180), idleRotation = false, emotion, setModelFallback, onLoaded, headMovement = false, bloom }) => {
  const ref = (0, import_react.useRef)(null);
  const { scene } = useGltfLoader(modelSrc);
  const { nodes } = useGraph(scene);
  scene.traverse((object) => {
    const node = object;
    if (node.name === "Wolf3D_Hands") {
      node.visible = false;
    }
    if (node.name === "RightHand") {
      node.position.set(0, -2, 0);
    }
    if (node.name === "LeftHand") {
      node.position.set(0, -2, 0);
    }
  });
  useFrame((state, delta) => {
    if (!idleRotation) {
      return;
    }
    if (ref === null || ref === void 0 ? void 0 : ref.current) {
      currentRotation += delta * 0.2;
      ref.current.rotation.y = rotation + Math.sin(currentRotation) / 3;
    }
  });
  useHeadMovement({ nodes, isHalfBody: true, enabled: headMovement });
  useIdleExpression("blink", nodes);
  useEmotion(nodes, emotion);
  useFallback(nodes, setModelFallback);
  return import_react.default.createElement(Model, { modelRef: ref, scene, scale, onLoaded, bloom });
};
var HalfBodyModelContainer = (props) => {
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback },
    import_react.default.createElement(HalfBodyModel, Object.assign({ setModelFallback: setFallback }, props))
  );
};
var PoseModel = ({ modelSrc, poseSrc, modelRef, scale = 1, emotion, setModelFallback, onLoaded, bloom }) => {
  const { scene } = useGltfLoader(modelSrc);
  const { nodes } = useGraph(scene);
  const pose = useGltfLoader(poseSrc);
  const { nodes: sourceNodes } = useGraph(pose.scene);
  mutatePose(nodes, sourceNodes);
  useEmotion(nodes, emotion);
  useFallback(nodes, setModelFallback);
  return import_react.default.createElement(Model, { modelRef, scene, scale, onLoaded, bloom });
};
var PoseModelContainer = (props) => {
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback },
    import_react.default.createElement(PoseModel, Object.assign({ setModelFallback: setFallback }, props))
  );
};
var EnvironmentModel = ({ environment, scale = 1, setModelFallback, onLoaded }) => {
  const transform = new Transform();
  const { scene } = useGltfLoader(environment);
  const { nodes } = useGraph(scene);
  useFallback(nodes, setModelFallback);
  (0, import_react.useEffect)(() => triggerCallback(onLoaded), [scene, onLoaded]);
  return import_react.default.createElement("group", null, Object.keys(nodes).map((key) => {
    const node = nodes[key];
    if (node.type === "Mesh") {
      return import_react.default.createElement("mesh", { receiveShadow: true, key: node.name, scale, position: transform.position, rotation: transform.rotation, geometry: node.geometry, material: node.material, morphTargetInfluences: node.morphTargetInfluences || [] });
    }
    return null;
  }));
};
var EnvironmentModelContainer = (props) => {
  const [fallback, setFallback] = (0, import_react.useState)(import_react.default.createElement(import_react.default.Fragment, null));
  const { environment } = props;
  const isStaticPreset = environment in environmentModels;
  const environmentSrc = isStaticPreset ? environmentModels[environment] : environment;
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback },
    import_react.default.createElement(EnvironmentModel, Object.assign({ setModelFallback: setFallback }, props, { environment: environmentSrc }))
  );
};
var controls;
var progress = Number.POSITIVE_INFINITY;
var updateCameraFocus = (camera, delta, target) => {
  if (target && progress <= 1) {
    camera.position.setX(lerp(camera.position.x, target.x, progress));
    camera.position.setZ(lerp(camera.position.z, target.z, progress));
    progress += delta;
  }
};
var updateCameraTarget = (camera, target, minDistance, maxDistance) => {
  if (controls) {
    let distance = controls.target.distanceTo(camera.position);
    distance = clamp(distance, maxDistance, minDistance);
    const pivot = (distance - minDistance) / (maxDistance - minDistance);
    controls.target.set(0, target - 0.6 * pivot, 0);
  }
};
var CameraControls = ({ cameraTarget, cameraInitialDistance, cameraZoomTarget, headScale = 1, controlsMinDistance = 0.4, controlsMaxDistance = 2.5, updateCameraTargetOnZoom = false }) => {
  const cameraZoomTargetRef = (0, import_react.useRef)(cameraZoomTarget);
  const { camera, gl } = useThree();
  const fallbackCameraTarget = cameraTarget || 1.475 + headScale / 10;
  const headScaleAdjustedMinDistance = controlsMinDistance + headScale / 10;
  (0, import_react.useEffect)(() => {
    var _a, _b, _c;
    if (((_a = cameraZoomTargetRef.current) === null || _a === void 0 ? void 0 : _a.x) !== (cameraZoomTarget === null || cameraZoomTarget === void 0 ? void 0 : cameraZoomTarget.x) || ((_b = cameraZoomTargetRef.current) === null || _b === void 0 ? void 0 : _b.y) !== (cameraZoomTarget === null || cameraZoomTarget === void 0 ? void 0 : cameraZoomTarget.y) || ((_c = cameraZoomTargetRef.current) === null || _c === void 0 ? void 0 : _c.z) !== (cameraZoomTarget === null || cameraZoomTarget === void 0 ? void 0 : cameraZoomTarget.z)) {
      cameraZoomTargetRef.current = cameraZoomTarget;
      progress = 0;
    }
    controls = new OrbitControls(camera, gl.domElement);
    controls.enableRotate = false;
    controls.enablePan = false;
    controls.minDistance = headScaleAdjustedMinDistance;
    controls.maxDistance = controlsMaxDistance;
    controls.minPolarAngle = 1.4;
    controls.maxPolarAngle = 1.4;
    controls.target.set(0, fallbackCameraTarget, 0);
    controls.update();
    if (cameraInitialDistance && progress === Number.POSITIVE_INFINITY) {
      camera.position.z = cameraInitialDistance;
      controls.update();
    }
    return () => {
      controls.dispose();
    };
  }, [
    cameraInitialDistance,
    camera,
    controlsMinDistance,
    controlsMaxDistance,
    fallbackCameraTarget,
    gl.domElement,
    headScaleAdjustedMinDistance,
    cameraZoomTarget
  ]);
  useFrame((_, delta) => {
    if (updateCameraTargetOnZoom) {
      updateCameraTarget(camera, fallbackCameraTarget, headScaleAdjustedMinDistance, controlsMaxDistance);
    }
    updateCameraFocus(camera, delta, cameraZoomTarget);
    if (controls) {
      controls.update();
    }
  });
  return null;
};
var css_248z = ".Loader-module_loader__Ukoov {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n\n.Loader-module_dots__KfhUo {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.Loader-module_dot__qTWRh {\n  background-color: rgb(236, 236, 236);\n  width: 8px;\n  height: 8px;\n  margin: 2px;\n  border-radius: 100%;\n  display: inline-block;\n}\n.Loader-module_dot__qTWRh:nth-child(1) {\n  animation: 0.75s cubic-bezier(0.2, 0.68, 0.18, 1.08) 0.12s infinite normal both running Loader-module_glowing__nwo3q;\n}\n.Loader-module_dot__qTWRh:nth-child(2) {\n  animation: 0.75s cubic-bezier(0.2, 0.68, 0.18, 1.08) 0.24s infinite normal both running Loader-module_glowing__nwo3q;\n}\n.Loader-module_dot__qTWRh:nth-child(3) {\n  animation: 0.75s cubic-bezier(0.2, 0.68, 0.18, 1.08) 0.36s infinite normal both running Loader-module_glowing__nwo3q;\n}\n\n@keyframes Loader-module_glowing__nwo3q {\n  0% {\n    transform: scale(1);\n    opacity: 1;\n  }\n  45% {\n    transform: scale(0.1);\n    opacity: 0.7;\n  }\n  80% {\n    transform: scale(1);\n    opacity: 1;\n  }\n}";
var styles = { "loader": "Loader-module_loader__Ukoov", "dots": "Loader-module_dots__KfhUo", "dot": "Loader-module_dot__qTWRh", "glowing": "Loader-module_glowing__nwo3q" };
styleInject(css_248z);
var Loader = () => import_react.default.createElement(
  "div",
  { className: styles.loader },
  import_react.default.createElement("div", { className: styles.dots }, [1, 2, 3].map((it) => import_react.default.createElement("div", { key: it, className: styles.dot })))
);
var Bloom2 = ({ luminanceThreshold = 1, luminanceSmoothing = 1, mipmapBlur = true, intensity = 0.1, kernelSize = 0 }) => import_react.default.createElement(Bloom, { luminanceThreshold, luminanceSmoothing, mipmapBlur, intensity, kernelSize });
var fromEntries = (arr) => Object.assign({}, ...arr.map(([k, v]) => ({ [k]: v })));
var definedProps = (obj) => fromEntries(
  // eslint-disable-next-line
  Object.entries(obj).filter(([k, v]) => v !== void 0)
);
var LIGHT_CONFIG = Object.freeze({
  fillLightAngle: Math.PI / 3,
  backLightAngle: Math.PI / 8,
  keyLightAngle: Math.PI,
  silhouetteLightAngle: Math.PI * 1.5,
  keyLightPosition: new Vector3(0.5, 1.55, 0.5),
  liftLightPosition: new Vector3(0.25, 1.7, 2),
  dirLightPosition: new Vector3(-0.75, 2.5, -1),
  silhouetteLightPosition: new Vector3(-1.5, 0.1, -1.5),
  defaultProps: {
    keyLightIntensity: 0.8,
    keyLightColor: "#FFFFFF",
    fillLightIntensity: 3,
    fillLightColor: "#6794FF",
    fillLightPosition: new Vector3(-0.5, 1.6, -0.5),
    backLightIntensity: 6,
    backLightColor: "#FFB878",
    backLightPosition: new Vector3(0.5, 1.6, -1),
    lightTarget: new Vector3(0, 1.7, 0)
  }
});
var Lights = (lightingProps) => {
  const { keyLightIntensity, keyLightColor, fillLightIntensity, fillLightColor, fillLightPosition, backLightIntensity, backLightColor, backLightPosition, lightTarget } = Object.assign(LIGHT_CONFIG.defaultProps, definedProps(lightingProps));
  const { scene } = useThree();
  const [targets] = (0, import_react.useState)({
    head: new Object3D(),
    shoe: new Object3D()
  });
  (0, import_react.useEffect)(() => {
    targets.head.position.copy(lightTarget);
    targets.shoe.position.set(0, 0, 0);
    scene.add(targets.head);
    scene.add(targets.shoe);
  }, []);
  return import_react.default.createElement(
    "group",
    null,
    import_react.default.createElement("spotLight", { position: fillLightPosition, target: targets.head, angle: LIGHT_CONFIG.fillLightAngle, color: fillLightColor, intensity: fillLightIntensity, castShadow: true }),
    import_react.default.createElement("spotLight", { position: backLightPosition, target: targets.head, angle: LIGHT_CONFIG.backLightAngle, color: backLightColor, intensity: backLightIntensity, castShadow: true }),
    import_react.default.createElement("spotLight", { position: LIGHT_CONFIG.keyLightPosition, target: targets.head, angle: LIGHT_CONFIG.keyLightAngle, color: keyLightColor, intensity: keyLightIntensity, castShadow: true }),
    import_react.default.createElement("spotLight", { position: LIGHT_CONFIG.liftLightPosition, target: targets.shoe, angle: LIGHT_CONFIG.keyLightAngle, color: keyLightColor, intensity: keyLightIntensity * 0.25, castShadow: true }),
    import_react.default.createElement("spotLight", { position: LIGHT_CONFIG.silhouetteLightPosition, target: targets.head, angle: LIGHT_CONFIG.silhouetteLightAngle, color: keyLightColor, intensity: keyLightIntensity * 0.25, castShadow: true })
  );
};
var CAMERA = {
  TARGET: {
    FULL_BODY: {
      MALE: 1.65,
      FEMALE: 1.55
    },
    HALF_BODY: 0.6
  },
  INITIAL_DISTANCE: {
    FULL_BODY: 0.4,
    HALF_BODY: 0.5
  },
  CONTROLS: {
    FULL_BODY: {
      MIN_DISTANCE: 0.5,
      MAX_DISTANCE: 3.2,
      ZOOM_TARGET: new Vector3(-0.11, 0, 3.2)
    },
    HALF_BODY: {
      MIN_DISTANCE: 0.4,
      MAX_DISTANCE: 1.4,
      ZOOM_TARGET: new Vector3(-0.15, 0, 0.55)
    }
  }
};
var Avatar = ({ modelSrc, animationSrc = void 0, poseSrc = void 0, environment = "soft", halfBody = false, shadows = false, scale = 1, cameraTarget = CAMERA.TARGET.FULL_BODY.MALE, cameraInitialDistance = CAMERA.INITIAL_DISTANCE.FULL_BODY, style, emotion, idleRotation = false, capture, background, onLoaded, onLoading, dpr, className, headMovement = false, cameraZoomTarget = CAMERA.CONTROLS.FULL_BODY.ZOOM_TARGET, onLoadedEffect, onLoadedAnimation, children, effects, keyLightIntensity, keyLightColor, fillLightIntensity, fillLightColor, fillLightPosition, backLightIntensity, backLightColor, backLightPosition, lightTarget, fov = 50 }) => {
  var _a, _b, _c, _d, _e;
  const setSpawnState = useSetAtom(spawnState);
  (0, import_react.useEffect)(() => {
    setSpawnState({ onLoadedEffect, onLoadedAnimation });
  }, [onLoadedAnimation, onLoadedEffect, setSpawnState]);
  const AvatarModel = (0, import_react.useMemo)(() => {
    if (!isValidFormat(modelSrc)) {
      return null;
    }
    if (!!animationSrc && !halfBody && isValidFormat(animationSrc)) {
      return import_react.default.createElement(AnimationModelContainer, { emotion, modelSrc, animationSrc, scale, idleRotation, onLoaded, headMovement, bloom: effects === null || effects === void 0 ? void 0 : effects.bloom });
    }
    if (halfBody) {
      return import_react.default.createElement(HalfBodyModelContainer, { emotion, modelSrc, scale, idleRotation, onLoaded, headMovement, bloom: effects === null || effects === void 0 ? void 0 : effects.bloom });
    }
    if (isValidFormat(poseSrc)) {
      return import_react.default.createElement(PoseModelContainer, { emotion, modelSrc, scale, poseSrc, onLoaded, bloom: effects === null || effects === void 0 ? void 0 : effects.bloom });
    }
    return import_react.default.createElement(StaticModelContainer, { modelSrc, scale, onLoaded, emotion, bloom: effects === null || effects === void 0 ? void 0 : effects.bloom });
  }, [halfBody, animationSrc, modelSrc, scale, poseSrc, idleRotation, emotion, onLoaded, headMovement, effects === null || effects === void 0 ? void 0 : effects.bloom]);
  (0, import_react.useEffect)(() => triggerCallback(onLoading), [modelSrc, animationSrc, onLoading]);
  return import_react.default.createElement(
    BaseCanvas,
    { position: new Vector3(0, 0, 3), fov, style, dpr, className },
    import_react.default.createElement(Environment2, { environment }),
    import_react.default.createElement(CameraControls, { cameraTarget, cameraInitialDistance, cameraZoomTarget, controlsMinDistance: halfBody ? CAMERA.CONTROLS.HALF_BODY.MIN_DISTANCE : CAMERA.CONTROLS.FULL_BODY.MIN_DISTANCE, controlsMaxDistance: halfBody ? CAMERA.CONTROLS.HALF_BODY.MAX_DISTANCE : CAMERA.CONTROLS.FULL_BODY.MAX_DISTANCE, updateCameraTargetOnZoom: !halfBody }),
    AvatarModel,
    children,
    shadows && import_react.default.createElement(ContactShadows, { position: [0, 0, 0], opacity: 2, scale: 10, blur: 1, far: 1 }),
    (background === null || background === void 0 ? void 0 : background.src) && import_react.default.createElement(Box, Object.assign({}, background)),
    capture && import_react.default.createElement(Capture, Object.assign({}, capture)),
    (background === null || background === void 0 ? void 0 : background.color) && import_react.default.createElement(BackgroundColor, { color: background.color }),
    ((effects === null || effects === void 0 ? void 0 : effects.ambientOcclusion) || (effects === null || effects === void 0 ? void 0 : effects.bloom) || (effects === null || effects === void 0 ? void 0 : effects.vignette)) && import_react.default.createElement(
      EffectComposer,
      { autoClear: true, multisampling: 4 },
      import_react.default.createElement(
        import_react.default.Fragment,
        null,
        (effects === null || effects === void 0 ? void 0 : effects.ambientOcclusion) && import_react.default.createElement(SSAO, { blendFunction: BlendFunction.MULTIPLY, distanceScaling: false, radius: 0.08, bias: 0.01, intensity: 3, samples: 31, worldDistanceThreshold: 24, worldDistanceFalloff: 0, worldProximityThreshold: 0, worldProximityFalloff: 6, fade: 0.02, rings: 8 }),
        (effects === null || effects === void 0 ? void 0 : effects.bloom) && import_react.default.createElement(Bloom2, { luminanceThreshold: (_a = effects === null || effects === void 0 ? void 0 : effects.bloom) === null || _a === void 0 ? void 0 : _a.luminanceThreshold, luminanceSmoothing: (_b = effects === null || effects === void 0 ? void 0 : effects.bloom) === null || _b === void 0 ? void 0 : _b.luminanceSmoothing, intensity: (_c = effects === null || effects === void 0 ? void 0 : effects.bloom) === null || _c === void 0 ? void 0 : _c.intensity, kernelSize: (_d = effects === null || effects === void 0 ? void 0 : effects.bloom) === null || _d === void 0 ? void 0 : _d.kernelSize, mipmapBlur: (_e = effects === null || effects === void 0 ? void 0 : effects.bloom) === null || _e === void 0 ? void 0 : _e.mipmapBlur }),
        (effects === null || effects === void 0 ? void 0 : effects.vignette) && import_react.default.createElement(Vignette, { eskil: false, offset: 0.5, darkness: 0.5 })
      )
    ),
    import_react.default.createElement(Lights, { keyLightIntensity, keyLightColor, fillLightIntensity, fillLightColor, fillLightPosition, backLightIntensity, backLightColor, backLightPosition, lightTarget })
  );
};
var AvatarWrapper = (props) => {
  var _a;
  return import_react.default.createElement(
    import_react.Suspense,
    { fallback: (_a = props.loader) !== null && _a !== void 0 ? _a : import_react.default.createElement(Loader, null) },
    import_react.default.createElement(
      Provider,
      null,
      import_react.default.createElement(Avatar, Object.assign({}, props))
    )
  );
};
var FloorReflection = (_a) => {
  var { resolution = 512, mixBlur = 0.8, mixStrength = 80, metalness = 0.5, blur = [300, 200], mirror = 1, minDepthThreshold = 0.4, maxDepthThreshold = 1.4, depthScale = 1.2, depthToBlurRatioBias = 1, distortion = 0, mixContrast = 1, reflectorOffset = 0, roughness = 1, color } = _a, props = __rest(_a, ["resolution", "mixBlur", "mixStrength", "metalness", "blur", "mirror", "minDepthThreshold", "maxDepthThreshold", "depthScale", "depthToBlurRatioBias", "distortion", "mixContrast", "reflectorOffset", "roughness", "color"]);
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement("fog", { attach: "fog", args: [color, 2, 6] }),
    import_react.default.createElement(
      "group",
      { position: [0, 0, 0] },
      import_react.default.createElement(
        "mesh",
        { rotation: [-Math.PI / 2, 0, 0] },
        import_react.default.createElement("planeGeometry", { args: [20, 10] }),
        import_react.default.createElement(MeshReflectorMaterial, Object.assign({ resolution, mixBlur, mixStrength, metalness, blur, mirror, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, distortion, mixContrast, reflectorOffset, roughness, color, envMapIntensity: 0 }, props))
      )
    )
  );
};
export {
  AnimationModelContainer as AnimationModel,
  AvatarWrapper as Avatar,
  CAMERA,
  EnvironmentModelContainer as EnvironmentModel,
  Exhibit,
  FloatingModelContainer as FloatingModel,
  FloorReflection,
  HalfBodyModelContainer as HalfBodyModel,
  PoseModelContainer as PoseModel,
  StaticModelContainer as StaticModel
};
//# sourceMappingURL=@readyplayerme_visage.js.map
